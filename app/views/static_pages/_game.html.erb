<!-- Game's javascript (place directly for now to reduce compiling time) -->
<!-- < %= javascript_pack_tag 'game' %> -->
<script>
// Resizes game's canvas (A.K.A. 'gameArea') to dynamic page size (i.e. When 
// user changes their browser's size)
window.addEventListener("resize", function(event) {
  canvas = document.getElementById("game-canvas");
  if (canvas.width  < window.innerWidth) {
    canvas.width  = window.innerWidth;
  }

  if (canvas.height < window.innerHeight) {
    canvas.height = window.innerHeight;
  }
});

// 'node' = 'window' in this case
// Deal with player token's controls 
window.addEventListener('keydown', function(event) {
  activeKeys[event.key] = true; // Player presses a key, true in array
});
window.addEventListener('keyup', function(event) {
  activeKeys[event.key] = false; // Player stops pressing key, false in array
});  

// Player token's name
var cassie = new playerToken(40, 40, "red");
let inv = new invaders();

// Object list of which current keys are being pressed (i.e. 'keydown') or not
var activeKeys = {};
var holding = '';
var invaderCount = 0;

// Function that toggles an element's visibility
const toggle = (elem) => {
    elem.classList.toggle('hidden');
}

var gameArea = {
  //cassie = new playerToken(40, 40, red, window.innerWidth/2, window.innerHeight),
  start : function() {
    // Make sure values are at their default when game is starting
    this.reset();
    this.canvas = document.getElementById("game-canvas");
    // Set demo text to indicate game is starting (for now, just to verify)
    document.getElementById("demo").innerHTML = "Game start";

    // Make canvas visible
    toggle(this.canvas);
    // Set up canvas dimensions
    this.canvas.width  = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.ctx = this.canvas.getContext("2d");

    // Set up player token's positioning
    cassie.x = this.canvas.width/2 - cassie.width/2;
    cassie.y = this.canvas.height - cassie.height; // accomodate for object's size

    let numInvaders = 8;
    let frameRate = 250;
    vDim = {vaderW: 50, vaderH: 60}; // Invader dimensions

    inv.setup(numInvaders, this.canvas.width, frameRate, vDim);

    // First argument:  Function that loops while game is active. Updates all game tokens
    // Second argument: Essentially how fast game will be moving (framerate)
    this.interval = setInterval(gameFrame, 5);
  },

  clear : function() {
    // [i] TODO using 'canvas' and 'ctx' in multiple functions of 'gameArea' need to DRY this out
    this.canvas = document.getElementById("game-canvas");
    this.ctx = this.canvas.getContext("2d");
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  },

  reset: function() {
    // All settings and game components are at their starting values
    //this.clear(); // Might not need this here

    clearInterval(this.interval); // nothing should be moving/responding
    // invaders
    invaders = []; // erase invaders 
  }
}

// Abstract object 
function gamePart(width, height, color = "blue", x = 0, y = 0, velocity = 0, speedBoost = 1) {
  this.width = width;
  this.height = height;
  this.color = color;
  // Object position in the (x, y) plane
  this.x = x;
  this.y = y;

  this.velocity = velocity;
  // A velocity multiplier 
  this.speedBoost = speedBoost;

  this.draw = function() { // Redraw according to new positioning
    ctx = gameArea.ctx;   
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7; // Opacity
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }

  // TODO: INHERITANCE and replace this function with a different one of the same name
  this.newPos = function() {
  } 

  // Determines whether or not one object has intersected another object's boundaries 
  this.collision = function() {
    // TODO
  }
}

function invaders() {
  // Invader's game token
  function invaderToken(width, height, color, x, y, velocity, speedBoost) {
    // invaderToken inherits from more generic gamePart class
    gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
    this.prototype = Object.create(gamePart.prototype);
    Object.defineProperty(this, 'constructor', { 
        value: invaderToken, 
        enumerable: false, // so that it does not appear in 'for in' loop
        writable: true 
    });  

    // TODO: INHERITANCE and replace this function with a different one of the same name
    this.newPos = function(lBound, rBound) {
      dist = this.x + this.velocity * this.speedBoost;

      // Stay in canvas' boundaries 
      // REMARK: Shapes drawn from uper right corner
      if(dist <= lBound && this.velocity < 0) {
        // Invader changes direction when boundary reached
        this.x = lBound;
        this.velocity *= -1;
        //if(dist == lBound) {
          this.y += 10;
        //}
      }
      else if(dist + this.width >= rBound && this.velocity > 0) {
        this.x = rBound - this.width; //toucn boundary then change direction
        this.velocity *= -1;
        //if(dist == rBound){
          this.y += 10;
        //}
      }
      else {
        this.x = dist;
      }
    } 
  }

  var invadArr = []; // Invader array
  // Default values in the event user does not call setup
  var invaderCount = 1;
  var canvas = 100;
  var frameUpper = 250;
  var frameNum = 0;
  var divvy = 10;
  var vw, vh; // invader width and height

  this.setup = function(numInvaders = 1, canvas = 100, frameRate = 250, {vaderH, vaderW}) {
    invadArr = []; // Make sure invader array is clear

    invaderCount = numInvaders;
    this.canvas = canvas;
    frameUpper = frameRate;
    frameNum = 0;
    divvy = this.canvas/invaderCount;

    vw =  vaderH;
    vh = vaderW;

    let drawAt = 0;
    let step = divvy/9; // invader will move in increments

    for(let i = 0; i < invaderCount; i ++) {
      invadArr.push(new invaderToken(vw, vh, "green", 
                    drawAt + divvy/2 - vw/2, 0, 1, step));
      drawAt += divvy;
    }
  }

  this.move = function() {
    // rbound starts at end of one divvy unit so it's ahead by one divvy
    let lbound = 0, rbound = divvy;
    // Causes invader movement to appear blocky as position updates less often
    if(frameNum++ >= frameUpper) {
      invadArr.forEach(function(invader) {
        invader.newPos(lbound, rbound); // TODO: Build boundaries within invaders
        invader.draw();
        // Move boundaries to fit next element
        lbound += divvy; 
        rbound += divvy;
      });
      frameNum = 0;
    }

    else {
      invadArr.forEach(function(invader) {
        // invader.newPos();
        invader.draw();// Won't be needed if dirty rectangles implemented
      });
    }
  }
}

// Can add new properties at the end of 'speedBoost'
function playerToken(width, height, color, x, y, velocity, speedBoost) {
  // playerToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: playerToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });

  // var canvas = document.getElementById("game-canvas");
  this.newPos = function() {
    // Variables tell what arrow keys are being pressed
    canvas = document.getElementById("game-canvas");
    right = activeKeys['ArrowRight'];
    left = activeKeys['ArrowLeft'];
    dist = this.x + this.velocity * this.speedBoost;
    if (left && !right) {
      holding = 'left';
      this.velocity = -1;
    }
    if(!left && right) {
      holding = 'right';
      this.velocity = 1;
    }
    if(left && right) {
      if(holding == 'right') { // Was holding right first
        this.velocity = -1; // Most recent is left
      }
      if(holding == 'left') { // Was holding left first
        this.velocity = 1; // Most recent is right
      }
      if(holding == '') { // Edge case, pressed both at exact time, choose one
        holding = 'right';
        this.velocity = -1; 
      }
    }
    if(!right && !left) {
      holding = '';
      this.velocity = 0;
    }

    // Stay in canvas' boundaries 
    if(dist == 0) {
      // Keep in the same place
    }
    else if(dist < 0) {
      this.x = 0;
    }
    else if(dist + this.width == canvas.width) {
      // Keep in the same place
    }
    else if(dist + this.width > canvas.width) {
      this.x = canvas.width - this.width; 
    }
    else {
      this.x = dist;
    }
  }
}

function gameFrame() {
  gameArea.clear(); // TODO: Optimize don't need to clear canvas each time
  cassie.newPos();
  cassie.draw();
  inv.move(); 
}

function gameOn() {
  gameArea.start();
}
</script>
<noscript>Error: Please download JavaScript for your browser.</noscript>


<!-- Page body -->

<!-- Canvas CSS (keep here for now for ease of editing) -->
<style>
  /*Include to hide HTML element by default*/
  .hidden {
    display: none;
  }

  #play-button {
    /*Needs absolute positioning to work even inside the canvas*/
    position: absolute;
  }

  html, body {
    /*Give page dimensions so canvas can encompass entirety of page*/
    width:  100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }

  #game-canvas {
    /*Temporary border*/
    border: 2px solid #38e3c4;
    position: absolute;
  }
</style>

<!-- Add game's canvas, initially hidden because it's only needed when user 
  decides to play the game and clicks play button -->
<canvas id="game-canvas" class="hidden"> 
Your browser does not support the HTML canvas tag.
</canvas>
<!-- Button click event: press to start the game script-->
<button id="play-button" type="button" onclick="gameArea.start()">Play</button>