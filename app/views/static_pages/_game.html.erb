<!-- Game's javascript (place directly for now to reduce compiling time) -->
<!-- < %= javascript_pack_tag 'game' %> -->
<script>
"use strict";

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~LISTENERS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Resizes game's canvas (A.K.A. 'gameArea') to dynamic page size (i.e. when 
// user changes their browser's size)
window.addEventListener("resize", function(event) {
  canvas = document.getElementById("game-canvas");
  if (canvas.width  != window.innerWidth) {
    canvas.width  = window.innerWidth;
  }
  if (canvas.height != window.innerHeight) {
    canvas.height = window.innerHeight;
  }
});

// Player token's controls 
// 'node' = 'window' in this case
window.addEventListener('keydown', function(event) {
  activeKeys[event.keyCode] = true; // Player presses a key, true in array
});
window.addEventListener('keyup', function(event) {
  activeKeys[event.keyCode] = false; // Player stops pressing key, false in array
});  

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GLOBAL VARIABLES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Player token's name
var cassie = new playerToken(40, 40, "red");
// Arguments presented as labeled parameters for clarity, the names 
// serve no purpose otherwise
// let inv = new invaders(totalInvaders = 8, {invaderWidth: 60, invaderHeight: 30}, 
//                        gapSpace = 30, velocity = 1, frameRate = 75);
var inv = new invaders(8, {invaderWidth: 60, invaderHeight: 30}, 30, 1, 75);
// Object list of key presses ('keydown'). False for unpressed or missing
var activeKeys = {};
var holding = '';

// Relevant keycodes 
const Space      = 32; // i.e. The spacebar 
const ArrowLeft  = 37;
const ArrowUp    = 38;
const ArrowRight = 39;
const ArrowDown  = 40;

// Stacked: Do not re-initialize invaders if already done before 
var invadersMem = false;
// Ensures game only starts every other click (start -> reset & stop -> start)
var go = true;

// Game canvas reference used throughout many object methods
// Canvas coordinates are as follows:
// (0,0) -- -- -- >(1,0)
//      |
//      |
//      |
//      V(0,1)

let canvas, ctx; // Set with 'init()' after page is loaded

let startLoop = false; // Starts/stops gameloop

// Keeps record of all shots/bullets
this.shotKeeper = new shotKeeper();

// Used to display frames per second
let timeStamp;
let secondsPassed = 0, oldTimeStamp = 0, fps;
// TODO: Reset timeStamp(?)
//let reqId; // Holds the requestId upon calling requestAnimationFrame

//______________________________________________________________________________
// [Bullet => invadArr(global)]
// Moving invadArr property from invaders inv object because for some reason I
// can't access invadArr as the ovbject's property!
var invadArr = [];
//______________________________________________________________________________

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~OBJECTS/FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
// Contingency, structurally script will already run after page is loaded
window.onload = getCanvas; // onload event to set canvas variables
function getCanvas() {
  canvas = document.getElementById("game-canvas");
  ctx = canvas.getContext("2d"); 
}

// Function that toggles an HTML element's visibility
const toggle = (elem) => {
  // Adds or removes 'hidden' class to element
  elem.classList.toggle('hidden');
}

// Entirety of game's 'screen', where all the visible game pieces are
var gameArea = {
  tog : function () {
    if (go == true) { // Initiate game
      go = false;
      // this.canvas = document.getElementById("game-canvas");
      startLoop = true;
      toggle(canvas); // Make canvas visible
      // Set demo text to indicate game is starting (for now, just to verify)
      document.getElementById("demo").innerHTML = "Game start";
      // Text on button changed to indicate pressing again ends the game
      document.getElementById("play-button").innerHTML = "Stop";
      this.start();
    }
    else { // End game, reset relevant variables
      // TODO: Reset timeStamp(?)
      //cancelAnimationFrame(reqId);
      timeStamp = 0;
      go = true;
      startLoop = false;
      // End game, press button again to "play" the game again (as of now, all
      // progress is lost after the currently existing hard reset)
      toggle(canvas); // Hide canvas
      document.getElementById("demo").innerHTML = "Game stop";
      document.getElementById("play-button").innerHTML = "Play";
      this.reset();
    }
  },

  //cassie = new playerToken(40, 40, red, window.innerWidth/2, window.innerHeight),
  start : function() {
    // PREP
    // Reset important variables
    this.reset();
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    cassie.setup();
    // Set up initial invader rows (use from stack if previous game played 
    // already)
    inv.setup();
    // Initialize structure that displays bullets (clears array)
    shotKeeper.setup();

    // LOOP
    // Initiate gameLoop, request function gives the browser some air while 
    // looping and time the game loop to be in-sync with the browser repaint
    startLoop = true;
    window.requestAnimationFrame(gameLoop);
  },

  clear : function() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  },

  reset: function() {
    // All settings and game components are at their starting values
    //this.clear(); // Might not need this here

    // clearInterval(this.interval); // nothing should be moving/responding
    // clearAnimationFrame(this.animationFrame);
    secondsPassed = 0;
    oldTimeStamp  = 0;
    timeStamp     = 0; // TODO: Reset timeStamp(?)
  }
}

function gameLoop(timeStamp) { // TODO: Reset timeStamp(?)
  if(!startLoop) {// Conditional that stops loop 
    return;
  }
  // [ 1 ] UPDATE
  // Calculate FPS
  secondsPassed = (timeStamp - oldTimeStamp)/1000;
  oldTimeStamp = timeStamp;

  fps = Math.round(1/secondsPassed);

  cassie.update(secondsPassed);
  cassie.shoot(); // Add bullets to shotKeeper (if any)
  inv.update(); // TODO: Add secondsPassed for consistency
  shotKeeper.update();

  // [Bullet => Check for collision]
  // [ 2 ] COLLISION DETECTION
  // TODO: Cassie
  // cassie.intersect();
  //____________________________________________________________________________  
  // [Bullets => iterate invaders]
  // BUG: CAN'T Access array??????
  // let vaderTotal = inv._getLength();
  for(let i = 0; i < invadArr.length; ++ i) {
    // shotKeeper.collisionCheck(invadArr[i]);
    // shotKeeper.collisionCheck(i); // Check collision with invader @ index i
    shotKeeper.collisionCheck(i);
  }
  //____________________________________________________________________________

  // [ 3 ] CLEAR
  gameArea.clear();

  // [ 4 ] DRAW
  cassie.draw();
  inv.draw();
  shotKeeper.draw();
  framesPerSecond(); // Just a display
  // TODO: Reset timeStamp(?)
  // document.getElementById("demo").innerHTML = "Sec: " + timeStamp;

  // Keep requesting further iterations of 'gameLoop' to animate game
  // TODO: Reset timeStamp(?)
  // reqId = window.requestAnimationFrame(gameLoop);
  window.requestAnimationFrame(gameLoop);
}

function framesPerSecond() { // Displays fps on canvas
  // Display FPS on canvas                  
  ctx.fillStyle = "rgba(0, 0, 0, 0)";
  ctx.fillRect(0, 0, 200, 100);
  ctx.font = '15px Arial';
  ctx.fillStyle = 'white';
  ctx.fillText("fps: " + fps, canvas.width - 50, canvas.height - 10);
}

function intersect(object1, object2) { // Checks if two boxes intersect
  if (object2.x > object1.x + object1.width   || 
      object1.x > object2.x + object2.width   || 
      object2.y > object1.y + object1.height  || 
      object1.y > object2.y + object2.height) {

      return false;
  }

  return true;
}

// Abstract object 

function gamePart(width = 50, height = 70, color = "blue", x = 0, y = 0, 
                  velocity = 1, magnitude = 1, collided = false) {
  this.width  = width;
  this.height = height;
  this.color  = color;
  // Object position in the (x, y) plane
  this.x = x;
  this.y = y;
  this.velocity  = velocity;
  this.magnitude = magnitude;

  // Set collision boolean
  this.collided = collided;

  this.setup = function() { // Stub

  }

  this.update = function() { // Stub

  }

  this.draw = function() { // Redraw according to new positioning   
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7; // Opacity
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

// Invader's game token
function invaderToken(width, height, color, x, y, velocity, magnitude = 1, 
                      collided = false) {
  // invaderToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, magnitude, collided);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: invaderToken, 
      enumerable: false, // So that it does not appear in 'for in' loop
      writable: true 
  });  
}

function invaders(invaderCount = 1, {invaderWidth = 10, invaderHeight = 10},
                  gapSpace = 20, velocity = 1, frameRate = 250) {
  //[LOCAL ARRAY]
  // Need to make this array accessible to the rest of the objects and their
  // functons to execute the same as now with it as a global variable (unable to
  // at the moment, though when testing it on the debug menu the array is 
  // initialized and everything)
  //----------------------------------------------------------------------------
  //var invadArr = [];
  //----------------------------------------------------------------------------
  this.invaderCount = invaderCount;
  var vw = invaderWidth;
  var vh = invaderHeight;

  var b = gapSpace; // Space [ b ]etween each invader
  this.velocity = velocity;
  var frameUpper = frameRate;

  var frameNum = 0; // Marks the current frame you're on
  var vLeftmost, vRightmost;
  // var moveRight = true;
  let magnitude;

  var wait = false; // 'turns' (frameRate) invaders must wait before moving again
  //[LOCAL ARRAY]
  //----------------------------------------------------------------------------
  // Accessor functions for the local invader array
  // this._getLength = function() { // Array length
  //   invadArr.length;
  // }

  // this._getVal = function(index) { // Return value at index
  //   invadArr[index];
  // }

  // this._getCollided = function(index) {
  //   invadArr[index].collided;
  // }

  // this._setCollided = function(index, _boolean = true) {
  //   invadArr[index].collided = _boolean;
  // }
  //----------------------------------------------------------------------------

  this.setup = function() {
    if(!invadersMem) {
      invadArr = []; // Make sure invader array is clear (sanity check mostly)
    }
    canvas.width = canvas.width;
    frameNum = 0; // Reset frame number

    // Invader setup and spacing

    // Relative space between each invader
    // X Coordinate of next invader (accounting for previous width)
    let next = vw + b;
    // Space between left most & rightmost invaders and the canvas boundary
    let edgeSpace = (canvas.width - invaderCount*vw - b*(invaderCount - 1))/2;
    let step = edgeSpace/5; // Arbitrary (get to evenly go to edge)
    let drawAt = edgeSpace; // Where to start invaders so group of them is centered

    if(!invadersMem) { // (First time) create array of invaders
      for(let i = 0; i < invaderCount; ++ i) { // Create invaders
        invadArr.push(new invaderToken(vw, vh, "green", drawAt, 0, 1, step,
                      false));
        drawAt += next;
      }
      invadersMem = true;
    }
    else { // Recycle invader array if it already existed
      invadArr.forEach(function(invader) { // Default invaders' positioning
        invader.x = drawAt;
        invader.y = 0;
        invader.collided = false;
        drawAt += next;
      });
    }
    // Reset speed and direction
    velocity = 1;
    magnitude = 1;
    // Reference for invaders on both ends of array
    vLeftmost  = invadArr[0];
    vRightmost = invadArr[invadArr.length - 1];
    vRightmost.magnitude = 30; // TODO: Replace vRightmost.magnitude with just an ordinary instance of magnitude (individual invaders might not need a speedboost defined, so it's wasted on them)
  }

  this.update = function() { // Update positioning
    if (frameNum ++ >= frameUpper) {
      frameNum = 0; // Reset frame

      if(wait) {
        invadArr.forEach(function(invader) {
          invader.y += 10;
        });
        wait = false;
      }
      else {
        let dist = velocity*vRightmost.magnitude;
        let distR = vRightmost.x + dist;
        let distL = vLeftmost.x + dist;

        // Movement based on canvas boundary collisions
        if(distR + vRightmost.width > canvas.width) { 
          velocity *= -1; // Change directions for next iteration
          // Calculate distance needed to reach rightmost canvas edge
          let finalDist = canvas.width - (vRightmost.x + vRightmost.width);

          invadArr.forEach(function(invader) { 
            // Move all invaders distance needed for rightmost invader to reach
            // canvas edge (and then move opposite direction next instance)
            invader.x += finalDist;
          });

          wait = true; // Make invaders wait at corner for two 'turns' (frameRate)
        }
        else if(distL < 0) {
          velocity *= -1;
          let finalDist = 0 - vLeftmost.x;

          invadArr.forEach(function(invader) {
            invader.x += finalDist;
          });

          wait = true;
        }
        else invadArr.forEach(function(invader) { 
          invader.x += dist;
        });
      }
    }
  }

  this.draw = function() {
    invadArr.forEach(function(invader) {
      if(!invader.collided) { // Collided invaders not drawn
        invader.draw();
      }
    });
  }
}

// Optional: With inheritance, can add new properties at the end of 'magnitude'
function playerToken(width, height, color, x, y, velocity = 1, magnitude = 125, 
                     fireRate = 20) {
  // playerToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, magnitude);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', {
      value: playerToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });

  this.velocity = velocity;
  this.magnitude = magnitude;
  var cooldown = 0;

  this.setup = function() {
    // Set up player token's positioning (bottom-center)
    // Subtracting(read: displacing) by player token dimensions to accomodate 
    // for token's size 
    cassie.x = canvas.width/2 - cassie.width/2;
    cassie.y = canvas.height  - cassie.height;
  }

  this.update = function(secondsPassed) {
    // Variables tell what arrow keys are being pressed
    // canvas = document.getElementById("game-canvas");
    let right = activeKeys[ArrowRight];
    let left = activeKeys[ArrowLeft];
    //dist = this.x + this.velocity * this.magnitude * secondsPassed;
    // dist = this.x + this.velocity * this.magnitude;

    // Player token direction based on arrow keys
    if (left && !right) {
      holding = 'left';
      this.velocity = -1;
    }
    if(!left && right) {
      holding = 'right';
      this.velocity = 1;
    }
    if(left && right) { // Special case: player holds both arrows
      if(holding == 'right') { // Was holding right first
        this.velocity = -1; // Most recent is left, so go left
      }
      if(holding == 'left') { // Was holding left first
        this.velocity = 1; // Most recent is right, so go right
      }
      if(holding == '') { // Edge case, pressed both at exact time, choose one
        holding = 'right';
        this.velocity = -1; 
      }
    }
    if(!right && !left) {
      holding = ''; // Reset, player is not holding either
      this.velocity = 0;
    }

    // (velocity = distance/time_passed) * const * time_passed = distance
    let dist = this.x + this.velocity * this.magnitude * secondsPassed;

    if(dist == 0) { // No movement

    }
    else if(dist < 0) { // Boundary
      this.x = 0;
    }
    else if(dist + this.width == canvas.width) { // Boundary
    }
    else if(dist + this.width > canvas.width) { // Boundary
      this.x = canvas.width - this.width; 
    }
    else { // Move
      this.x = dist;
    }
  }

  this.shoot = function() {
    let space = activeKeys[Space]; // Press Enter to shoot

    if (space && cooldown ++ > fireRate) { // Attempt at limiting bullets / sec
      cooldown = 0;
      // (x,y) displacement accomodates for token's dimensions
      // Negative velocity because player's bullets go up
      shotKeeper.addShot(5, 10, "yellow", this.x + width/2, this.y - height/2, 
                         -1, 125);
    }
  }
}

// Is there a better way to define an object with properties? Because this 
// function will not be used as a data type or anything
function shotKeeper() { // Object in charge of keeping tabs on all bullets
  // Note: might reset bullet array upon game ending (at least until efficient 
  // way of storing and re-using them is possibly found)
  var shots = [];

  this.setup = function() { // Run1 on game start
    shots = []; // Resets bullet array
  }

  // TODO: Is there a way to reference gamePart for this?? They essentially take
  // the same parameters
  this.addShot = function(width = 5, height = 15, color = "blue", x = 70, y = 70,
                          velocity = 1, magnitude = 500, collided = false) {
    this.width = width;
    this.height = height;
    this.color = color;
    this.x = x;
    this.y = y;
    this.velocity = velocity;
    this.magnitude = magnitude;
    this.collided = collided;
                              
    // var bullet = new gamePart(width, height. color, x, y, velocity, magnitude);   
    shots.push(new gamePart(this.width, this.height, this.color, this.x, this.y, 
                            this.velocity, this.magnitude, this.collided));
  }

  // Redefine clear/draw to render all the bullets. Probably though can use the
  // same kind of approach as invaders, defining a 'move' property. If so, then
  // I can DRY out the methods' code into a single function, and use said 
  // function in each object class!! <- may be unable to due to how certain
  // things move, and movement is simply adding/subtracting x and y. The draws
  // are already DRYed out
  this.update = function() {
    //TODO: Add collision check, remove if collision
    // Delete individual shot if it leaves canvas (cleanup)
    // Movement
    shots.forEach(function(shot) {
      if(shot.y > canvas.height || shot.y < 0) {
        shots.splice(shot, 1); 
      }
      else {
        shot.y += shot.velocity*shot.magnitude*secondsPassed;
      }
    });
  }

  //[LOCAL ARRAY]
  //----------------------------------------------------------------------------
  // Make it so that this function can interact with local array by using the
  // defined accessor methods
  this.collisionCheck = function(index) {
  //----------------------------------------------------------------------------
    let thisVader = invadArr[index];
    // thisVader = inv._getVal(index); // Get value of current invader

    shots.forEach(function(shot) {
      // T0D0 => way to fix THIS??????????????????????>?>?>?>?>?>?>?>?>?>?>?>?>?
      //------------------------------------------------------------------------
      // let collides = intersect(shot, token);
      //------------------------------------------------------------------------
      let collides = intersect(shot, thisVader);
      if (collides) {
        // shot.collided      = true;``
        shot.collided = true;
        // Bullet and invader cancel each other
        // T0D0 ################################################################
        // [Bullet => Invader intact?]
        // if(!token.collided) { 
        // if(!inv._getCollided(index)) {
        if(!thisVader.collided) {
          shots.splice(shot, 1);
          // [Bullet => collision]
          invadArr[index].collided = true;
          // Array setter ------------------------------------------------------
          // inv._setCollided(index, true);
        }
      }
    });
  }
  //____________________________________________________________________________

  this.draw = function() {
    document.getElementById("bull").innerHTML = "bullets: " + shots.length;
    shots.forEach(function(shot) {
      shot.draw();
    });
  }
}
</script>
<noscript>Error: Please download JavaScript for your browser.</noscript>

<!-- ----------------------------------------------------------------------- -->
                               <!-- Page body -->

<!-- Canvas CSS (keep here for now for ease of editing) -->
<style>
  /*Include to hide HTML element by default*/
  .hidden {
    display: none;
  }

  #play-button {
    /*Needs absolute positioning to work even inside the canvas*/
    position: absolute;
  }

  html, body {
    /*Give page dimensions so canvas can encompass entirety of page*/
    width:  100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }

  #game-canvas {
    /*Temporary border*/
    border: 2px solid #38e3c4;
    position: absolute;
    /*TODO: Make good scaling*/
/*    width: 100%;
    height: 100%;*/
  }
</style>