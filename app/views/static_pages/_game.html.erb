<!-- Game's javascript (place directly for now to reduce compiling time) -->
<!-- < %= javascript_pack_tag 'game' %> -->
<script>
// Resizes game's canvas (A.K.A. 'gameArea') to dynamic page size (i.e. When 
// user changes their browser's size)
window.addEventListener("resize", function(event) {
  canvas = document.getElementById("game-canvas");
  if (canvas.width  < window.innerWidth) {
    canvas.width  = window.innerWidth;
  }

  if (canvas.height < window.innerHeight) {
    canvas.height = window.innerHeight;
  }
});

// Deal with player token's controls 
// 'node' = 'window' in this case
window.addEventListener('keydown', function(event) {
  activeKeys[event.key] = true; // Player presses a key, true in array
});
window.addEventListener('keyup', function(event) {
  activeKeys[event.key] = false; // Player stops pressing key, false in array
});  

// Player token's name
var cassie = new playerToken(40, 40, "red");
// Arguments presented as labeled parameters for ease of reading, they serve
// no purpose otherwise
let inv = new invaders(totalInvaders = 8, {invaderWidth: 60, invaderHeight: 30}, 
                       gapSpace = 30, velocity = 1, frameRate = 75);

// Object list of which current keys are being pressed (i.e. 'keydown') or not
var activeKeys = {};
var holding = '';

// Stacked: Do not re-initialize invaders if already done before 
var invadersMem = false;
// Ensures game only starts every other click (Start, reset-stop, etc.)
var go = true;

var canvas = document.getElementById("game-canvas");
var ctx = canvas.getContext("2d");

// Keeps record of all shots/bullets
this.shotKeeper = new shotKeeper();

// Function that toggles an element's visibility
const toggle = (elem) => {
    elem.classList.toggle('hidden');
}

var gameArea = {
  tog : function () {
    if (go == true) {
      go = false;
      // this.canvas = document.getElementById("game-canvas");
      toggle(canvas);
      document.getElementById("play-button").innerHTML = "Stop";
      this.start();
    }
    else {
      go = true;
      toggle(canvas);
      document.getElementById("demo").innerHTML = "Game stop";
      document.getElementById("play-button").innerHTML = "Play";
      this.reset();
    }
  },

  //cassie = new playerToken(40, 40, red, window.innerWidth/2, window.innerHeight),
  start : function() {
    // Make sure values are at their default when game is starting
    // this.reset();
    // this.canvas = document.getElementById("game-canvas");
    // Set demo text to indicate game is starting (for now, just to verify)
    document.getElementById("demo").innerHTML = "Game start";
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    // Set up player token's positioning
    cassie.x = canvas.width/2 - cassie.width/2;
    cassie.y = canvas.height - cassie.height; // accomodate for object's size

    inv.setup(canvas.width);

    // First argument:  Function that loops while game is active. Updates all game tokens
    // Second argument: Essentially how fast game will be moving (framerate)
    this.interval = setInterval(gameFrame, 5);

    shotKeeper.setup();
  },

  clear : function() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  },

  reset: function() {
    // All settings and game components are at their starting values
    //this.clear(); // Might not need this here

    clearInterval(this.interval); // nothing should be moving/responding
  }
}

// Abstract object 
function gamePart(width = 50, height = 70, color = "blue", x = 0, y = 0, 
                  velocity = 1, speedBoost = 1) {
  this.width = width;
  this.height = height;
  this.color = color;
  // Object position in the (x, y) plane
  this.x = x;
  this.y = y;
  this.velocity = velocity;
  this.speedBoost = speedBoost;

  this.draw = function() { // Redraw according to new positioning   
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7; // Opacity
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }

  // TODO: INHERITANCE and replace this function with a different one of the same name
  this.newPos = function() {
  } 

  // Determines whether or not one object has intersected another object's boundaries 
  this.collision = function() {
    // TODO
  }
}

// Invader's game token
function invaderToken(width, height, color, x, y, velocity, speedBoost = 1) {
  // invaderToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: invaderToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });  
}

function invaders(invaderCount = 1, {invaderWidth = 10, invaderHeight = 10},
                  gapSpace = 20, velocity = 1, frameRate = 250) {
  var invadArr = [];

  // Set invader properties to argument counterpart values
  this.invaderCount = invaderCount;
  var vw = invaderWidth;
  var vh = invaderHeight;

  var b = gapSpace; // Space [ b ]etween each invader
  this.velocity = velocity;
  var frameUpper = frameRate;

  var frameNum = 0; // Marks the current frame you're on
  var vLeftmost, vRightmost;
  // var moveRight = true;

  var wait = false; // 'turns' (frameRate) invaders must wait before moving again

  this.setup = function(can = 100) {
    if(!invadersMem) {
      invadArr = []; // Make sure invader array is clear
    }
    canvasW = can; // Get canvas width from setup method call
    frameNum = 0; // Reset frame number
    // moveRight = true;

    // Invader setup and spacing

    // Relative space between each invader
    // X Coordinate of next invader accounting for previous width
    let next = vw + b;
    // Space between left most & rightmost invaders and the canvas boundary
    let edgeSpace = (canvasW - invaderCount*vw - b*(invaderCount - 1))/2;
    let step = edgeSpace/5; // Arbitrary (get to evenly go to edge)
    let drawAt = edgeSpace; // Where to start invaders so group of them is centered

    if(!invadersMem) {
      for(let i = 0; i < invaderCount; ++ i) { // Create invaders
        invadArr.push(new invaderToken(vw, vh, "green", drawAt, 0, 1, step));
        drawAt += next;
      }
      invadersMem = true;
    }
    else {
      invadArr.forEach(function(invader) { // Reset invader positioning
        invader.x = drawAt;
        invader.y = 0; // Stacked: Need to fix invaders, moving when canvas hidden
        drawAt += next;
      });
    }
    // Reference for invaders on both ends of array
    vLeftmost  = invadArr[0];
    vRightmost = invadArr[invadArr.length - 1];
    vRightmost.speedBoost = 30; // TODO: Replace vRightmost.speedBoost with just an ordinary instance of speedboost (individual invaders might not need a speedboost defined, so it's wasted on them)
  }

  this.move = function() {
    if (frameNum ++ >= frameUpper) {
      frameNum = 0; // Reset frame

      if(wait) {
        invadArr.forEach(function(invader) {
          invader.y += 10;
        });
        wait = false;
      }
      else {
        dist = velocity*vRightmost.speedBoost;
        distR = vRightmost.x + dist;
        distL = vLeftmost.x + dist;

        // Movement based on canvas collision
        if(distR + vRightmost.width > canvasW) { 
          velocity *= -1; // Change directions for next iteration
          // Calculate distance neede to reach rightmost canvas edge
          finalDist = canvasW - (vRightmost.x + vRightmost.width);

          invadArr.forEach(function(invader) { 
            // Move all invaders distance needed for rightmost invader to reach
            // canvas edge
            invader.x += finalDist;
          });

          wait = true; // Make invaders wait at corner for two 'turns' (frameRate)
        }
        else if(distL < 0) {
          velocity *= -1;
          finalDist = 0 - vLeftmost.x;

          invadArr.forEach(function(invader) {
            invader.x += finalDist;
          });

          wait = true;
        }
        else invadArr.forEach(function(invader) { 
          invader.x += dist;
        });
      }
    }
    // Redraw
    invadArr.forEach(function(invader) {
      invader.draw();// Optimize1, Won't be needed if dirty rectangles 
                     // implemented
    });
  }
}

// Optional: With inheritance, can add new properties at the end of 'speedBoost'
function playerToken(width, height, color, x, y, velocity = 0, speedBoost = 1, fireRate = 100) {
  // playerToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: playerToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });

  this.velocity = velocity;
  this.speedBoost = speedBoost;
  var cooldown = 0;

  // var canvas = document.getElementById("game-canvas");
  this.newPos = function() {
    // Variables tell what arrow keys are being pressed
    // canvas = document.getElementById("game-canvas");
    right = activeKeys['ArrowRight'];
    left = activeKeys['ArrowLeft'];
    dist = this.x + this.velocity * this.speedBoost;
    if (left && !right) {
      holding = 'left';
      this.velocity = -1;
    }
    if(!left && right) {
      holding = 'right';
      this.velocity = 1;
    }
    if(left && right) { // Special case: player holds both arrows
      if(holding == 'right') { // Was holding right first
        this.velocity = -1; // Most recent is left
      }
      if(holding == 'left') { // Was holding left first
        this.velocity = 1; // Most recent is right
      }
      if(holding == '') { // Edge case, pressed both at exact time, choose one
        holding = 'right';
        this.velocity = -1; 
      }
    }
    if(!right && !left) {
      holding = ''; // Reset, player is not holding either
      this.velocity = 0;
    }

    // Stay in canvas' boundaries 
    if(dist == 0) {
      // Keep in the same place
    }
    else if(dist < 0) {
      this.x = 0;
    }
    else if(dist + this.width == canvas.width) {
      // Keep in the same place
    }
    else if(dist + this.width > canvas.width) {
      this.x = canvas.width - this.width; 
    }
    else {
      this.x = dist;
    }
  }

  this.shoot = function() {
    space = activeKeys['Enter'];

    if (space && cooldown ++ > fireRate) { 
      cooldown = 0;
      shotKeeper.addShot(5, 10, "red", this.x, this.y, 1, 1);
    }
  }
}

function shotKeeper() {
  // Note: might reset bullet array upon game ending (at least until efficient 
  // way of storing and re-using them is possibly found)
  var shots = [];

  this.setup = function() { // Run on game start
    shots = []; // Resets bullet array
  }

  // TODO: Is there a way to reference gamePart for this?? They essentially take
  // the same parameters
  this.addShot = function(width = 5, height = 15, color = "red", x = 300, 
                          y = 300, velocity = 1, speedBoost = 1) {
    this.width = width;
    this.height = height;
    this.color = color;
    this.x = x;
    this.y = y; 
    this.velocity = velocity;
    this.speedBoost = speedBoost;
                              
    // var bullet = new gamePart(width, height. color, x, y, velocity, speedBoost);                             
    shots.push(new gamePart(width, height. color, x, y, velocity, speedBoost));
  }

  this.remShot = function(shot) { // Removes a single shot from array
    shots.splice(shot, 1);
  }

  // Redefine clear/draw to render all the bullets. Probably though can use the
  // same kind of approach as invaders, defining a 'move' property. If so, then
  // I can DRY out the methods' code into a single function, and use said 
  // function in each object class!! <- may be unable to due to how certain
  // things move, and movement is simply adding/subtracting x and y. The draws
  // are already DRYed out

  this.move = function() {
    shots.forEach(function(shot) {
      //TODO: Add collision check, remove if collision
      // Delete shot from array if it's no longer in view
      if(shot.y > canvas.height || shot.y < 0) {
        shots.splice(shot, 1);
      }
      else {
        shot.draw();
      }
      // Movement
      shot.y += shot.velocity*shot.speedBoost;
    });
  }
}

function gameFrame() {
  gameArea.clear(); // TODO: Optimize1, don't need to clear canvas each time 
                    // (rectangles? Note: may be a depreciated concept)
  cassie.newPos();
  cassie.draw();
  cassie.shoot();

  shotKeeper.move();
  inv.move(); 
}
</script>
<noscript>Error: Please download JavaScript for your browser.</noscript>


<!-- Page body -->

<!-- Canvas CSS (keep here for now for ease of editing) -->
<style>
  /*Include to hide HTML element by default*/
  .hidden {
    display: none;
  }

  #play-button {
    /*Needs absolute positioning to work even inside the canvas*/
    position: absolute;
  }

  html, body {
    /*Give page dimensions so canvas can encompass entirety of page*/
    width:  100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }

  #game-canvas {
    /*Temporary border*/
    border: 2px solid #38e3c4;
    position: absolute;
  }
</style>