<!-- Game's javascript (place directly for now to reduce compiling time) -->
<!-- < %= javascript_pack_tag 'game' %> -->
<script>
"use strict";

/**
 * requestAnim shim layer by Paul Irish
 * Finds the first API that works to optimize the animation loop,
 * otherwise defaults to setTimeout().
 */
// window.requestAnimFrame = (function(){
//   return  window.requestAnimationFrame   ||
//       window.webkitRequestAnimationFrame ||
//       window.mozRequestAnimationFrame    ||
//       window.oRequestAnimationFrame      ||
//       window.msRequestAnimationFrame     ||
//       function(/* function */ callback, /* DOMElement */ element){
//         window.setTimeout(callback, 1000 / 60);
//       };
// })();

//*********************************LISTENERS***********************************
// Contingency, structurally script will already run after page is loaded
window.onload = getCanvas; // onload event to set canvas variables
function getCanvas() {
  canvas = document.getElementById("game-canvas");
  ctx = canvas.getContext("2d");
}

// Function that toggles an HTML element's visibility (used on canvas)
const toggle = (elem) => {
  // Adds or removes 'hidden' class to element
  elem.classList.toggle('hidden');
}

// Resizes game's canvas (A.K.A. 'gameArea') to dynamic page size (i.e. when 
// user changes their browser's size)
window.addEventListener("resize", function(event) {
  canvas = document.getElementById("game-canvas");

  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
});

// Resize canvas from the get-go
window.addEventListener("load", function(event) { 
  canvas = document.getElementById("game-canvas");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});  

// Player token's controls 
// 'node' = 'window' in this case
window.addEventListener('keydown', function(event) {
  activeKeys[event.keyCode] = true; // Player presses a key, true in array
});

window.addEventListener('keyup', function(event) {
  activeKeys[event.keyCode] = false; // Player stops pressing key, false in array
}); 

// *****************************GLOBAL VARIABLES*******************************
// TODO: Add a x and y velocity (invaders should have a difference in case of needing it later)

// Object list of key presses ('keydown'). False for unpressed or missing
var activeKeys = {};
var holding = '';

// Listeners' pertinent keycodes 
const Space      = 32; // i.e. The spacebar 
const ArrowLeft  = 37;
const ArrowUp    = 38;
const ArrowRight = 39;
const ArrowDown  = 40;

//BUG1 Keep track of frontmost player bullet's height
let playerBH = 0;
// let first = true;

// Stacked: Do not re-initialize invaders if already done before 
var invadersMem = false;
// Ensures game only starts every other click (start -> reset & stop -> start)
var go = true;

// Game canvas reference used throughout many object methods
// Canvas coordinates are as follows:
// (0,0) -- -- -- >(1,0)
//      |
//      |
//      |
//      V(0,1)

// Capture values when page loads
let canvas, ctx; // Set with 'init()' after page is loaded

// Keeps record of all shots/bullets

// Used to display frames per second
let timeStamp = 0;
let dt = 0, oldTimeStamp = 0, fps;
// TODO: Reset timeStamp(?)
let reqId; // Holds the requestId upon calling requestAnimationFrame

//*****************************OBJECTS/FUNCTIONS*******************************
// vectors for game mechanics and positioning (note: game is 2d for now)
function vector2d(x, y) {
  this.x = x;
  this.y = y;
}

// Vector functions
// Note: arguments used are unaltered
function vector2dAdd(v1, v2) {
  return new vector2d(v1.x + v2.x, v1.y + v2.y);
}

function vector2dSubtract(v1, v2) {
  return new vector2d(v1.x - v2.x, v1.y - v2.y);
}

function vector2dDot(v1, v2) { // dot product //PLACEMAT
  return v1.x * v2.x + v1.y * v2.y;
}

function vectorTimesScalar(v1, s) { // multiply vector parameters by a constant
  return new vector2d(v1.x * s, v2.x * s);
}

function vectorLength(v) { // apply distance formula âˆš(x^2 + y^2)
  return Math.sqrt(vector2dDot(v, v));
}

function vectorNormal(v) { // returns normalized vector (length = 1)
  let l = vectorLength(v);

  if(l == 0) { // note: if l == 0, then don't divide by zero, it's forbidden
    return null;
  }
  var reciprocal = 1 / vectorLength(v);

  return vectorTimesScalar(v, reciprocal);
}

// Images
// Load game sprites/images
var imgRepo = new function(nImages = 1) { // Class instance
  // IMAGE DEFINITIONS
  this.player_token = new Image();
  
  // IMAGE LOADING
  // Don't start game until all images are done loading
  this.nImages = nImages; 
  let nLoaded = 0;

  let imgLoaded = function() {
    if(nLoaded ++ == nImages) {
      // window.init(); // Start game TODO: Create a title screen (and only load
                        // game when all images are loaded)
    }
  }

  this.player_token.onload = function() {
    imgLoaded(); // Increment total loaded images by one
  }
  // SET IMAGE SOURCES
  this.player_token.src = "/assets/token_player1.svg";
};

// Renderer object
//MOVE DOWN below gamearea
var renderer = (function() { // Note: context = ctx for now, later, the 'context' 
  // methods to draw specific game tokens (they don't look through stored 
  // tokens)
                             // variable will be defined internally 
  function _drawRectangle(context, token) { // Generic rectangle
    ctx.fillStyle = token.color;
    ctx.globalAlpha = 0.7; // Opacity
    // Since drawing starts at upper-lefthand corner
    ctx.fillRect(token.position.x - token.width/2, 
      token.position.y - token.height/2, token.width, token.height); 
  }

  function _drawPlayer(context, token) { // render player token
    ctx.drawImage(imgRepo.player_token, token.position.x - token.width/2, 
      token.position.y - token.height/2, token.width, token.height);
  }

  // WiP: No invader sprite yet. Draw as a plain token (a rectangle)
  function _drawInvader(context, token) { // render invader tokens
    _drawRectangle(context, token);
  }

  // method to draw all game tokens
  function _render() {
    // TODO: Move the gloval canvas variables here
    // var canvas = document.getElementById("game-canvas");
    let ctx = canvas.getContext("2d"); // rendering in two dimensions

    // Example of a more C ++ approach to the loop:
    // var i,
    //     entity,
    //     entities = gameArea.entities(); // get tokens
    //
    //     for(i = 0; i < entities.length; i ++) { // Drawing loop
    //       entity = entities[i];
    //
    //       if(entity instanceof playerToken) {
    //         _drawPlayer(ctx, entity);
    //       }
    //     }

    // Draw all game tokens
    gameArea.entities().forEach(function(entity) {
      if(!entity.collided) { // Intact tokens only
        if(entity instanceof playerToken) {
          _drawPlayer(ctx, entity);
        }
        else if(entity instanceof invaderToken) {
          _drawInvader(ctx, entity);
        }
        else { // Default, rectangular polygon
          _drawRectangle(ctx, entity);
        }
      }
    });

    gameArea.shots().forEach(function(shot) {
      _drawRectangle(ctx, shot);
    });
  }

  function _clear() { // clear entire canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  return { // Accessors
    render: _render, // Public method(s)
    clear:  _clear
  };

})();

var physics = (function () {
  var _shotKeeper = new _shotKeeper(); // shotKeeper class instance

  // Updates 
  // TODO: Also handles collisions
  function _update() {
    gameArea.entities.forEach(function(entity) {
      // TODO: Need to implement both X and Y directions (only use one of those atm)
      // entity.y += entity.y.direction
      
    });
  }

  // Is there a better way to define an object with properties? Because this 
  // function will not be used as a data type or anything
  function _shotKeeper() { // class in charge of keeping tabs on all bullets
    this.addShot = function(position, width = 5, height = 15, direction, speed, collided  = false, color = "blue") {
      // Given where bullet should spawn (x, y) but need to center the bullet
      // TODO: Make bullet spawn without touching player, account for this 
      // Can possibly circumvent this by differentiating player and invader
      // bullets
      // GRID need to change shot depending on if player or invader shoot it 
      // (displacement/side it comes out from is different)
      // Can do this under the function call for each of them (TODO) then
      // won't have to specify the position here, but in the addShot call in
      // either the invader or the player
      this.position  = new vector2d(position.x, position.y - height/2);
      this.width     = width;
      this.height    = height;
      this.direction = direction;
      this.speed     = speed;
      this.collided  = collided;
      this.color     = color;
     
      gameArea.shots().push(new gameToken(this.position, this.width, this.height, this.direction, this.speed, this.collided, this.color));
    }

    // Redefine clear/draw to render all the bullets. Probably though can use the
    // same kind of approach as invaders, defining a 'move' property. If so, then
    // I can DRY out the methods' code into a single function, and use said 
    // function in each object class!! <- may be unable to due to how certain
    // things move, and movement is simply adding/subtracting x and y. The draws
    // are already DRYed out
    this.update = function() {
      //TODO: Add collision check, remove if collision
      // Delete individual shot if it leaves canvas (cleanup)
      // Movement
      gameArea.shots().forEach(function(shot) {
        // Check bounds
        if(shot.hitbox().top() > canvas.height || shot.hitbox().bottom() < 0) {
          gameArea.shots().splice(shot, 1);
        }
        // **********************************************************************
        else { // advance
          let yVelocity = shot.direction.y * shot.speed.y;
          shot.position.y += yVelocity * dt;
        }
        // **********************************************************************
      });
    }

    this.collisionCheck = function(token) {
      // STANDBY3: Only pay attention to front row for now
      // let thisVader = invadarr.a[1][index]; // get value of invader in question

      gameArea.shots().forEach(function(shot) {
        //let collides = intersect(shot, token); // Way to fix this (?)
        if (shot.hitbox().intersect(token.hitbox())) {
          shot.collided = true;
          // Bullet and invader cancel each other
          // T0D0 ###############################################################
          // [Bullet => Invader intact?]
          // if(!token.collided) { 
          // if(!_inv._getCollided(index)) {
          if(!token.collided) {
            gameArea.shots().splice(shot, 1); // Intact token disappears along with bullet
            // [Bullet => collision]
            // invadarr.a[1][index].collided = true;
            token.collided = true;
          }
        }
      });
    }
  }

  return {
    update:     _update,
    shotKeeper: _shotKeeper
  };

})();

// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// Entirety of game's 'screen', where all the visible game pieces are
var gameArea = (function() { // Singleton
  // variables
  // game token variables:
  // Hold all game tokens used in the game
  var _entities = []; // Holds all (generic) game tokens
  // Player token's name
  var _player1 = new playerToken(new vector2d(0, 0), 70, 70, new vector2d(1, 0), new vector2d(125, 5)); //5 isn't active atm since direction is x axis only
  // --------------------------------------------------------------------------
  // TODO:Attempt to separate game objects from their drawing and physics by
  // keeping their data here and implementing the other actions in two different
  // objects, in general can keep everything in one var, but a modular 
  // TODO: Replace _inv with _inv and return the _inv equivalent, see if anything needs the _inv and replace it with the following call: gameArea._inv()
  var _inv = new invaders(/*totalInvaders*/ 4, 
                        {invaderWidth: 80, invaderHeight: 20}, 
                        /*gapSpace*/       30, 
                        /*velocity*/       new vector2d(100, 10),
                        /*frameRate*/      100); // how often they move forward (in one huge step since time isn't accounted for in their 'velocity', causing a shuttering/blinking effect)
  // implementation 

  // methods
  // var _invaders =  []; // Holds all invaders
  let _invadarr = (function() { // 2d invader array
    //  a: {},  // Associative array, doesn't have built-in methods (ex. length())
    let a = [],
        f = [], // Invaders in the frontline (those allowed to shoot) 
        r = 0;  // total rows

    function _totCols(rowIndex) { // Total number of columns for given row
      if(rowIndex < this.r) {
        return this.a[rowIndex].length;
      }
      else {
        return false; // Out of bounds
      }
    }

    function _addRows(numOf) { // Add specific number of rows
      for(let i = 0; i < numOf; i ++) {
        this.a[this.r ++] = [];
      }
    }

    function _clear() {
      this.a = []; // Reset entire array content
      this.r = 0; // No rows on empty array
    }

    function _setup() {
      // Set up frontline invaders
      this.f = []; // erase previous values
      // let frontliners = this.a[this.r - 1];
      this.f = this.a[this.r - 1]; // Reset frontline to frontmost array

      // for(let i = 0; i < frontliners.length; i ++) {
      //   this.f.push(frontliners[i]);
      // }
    }

    return {
      totCols: _totCols, // method accessors
      addRows: _addRows,
      clear:   _clear,
      setup:   _setup,
      totRows:  function()  { return r; }, // data accessors
      totFront: function()  { return f; }
    };
  })();

  // gameArea variables:
  let _shots  =  []; // Holds all bullets
  let startLoop = false; // Starts/stops gameloop
  // --------------------------------------------------------------------------
  function _tog() {
    //BUG1
    if (go == true) { // Initiate game    
      go = false;
      startLoop = true;
      toggle(canvas); // Make canvas visible
      // Make demo say game's running, make button say stop (toggles play/stop)
      document.getElementById("demo").innerHTML = "Game start";
      document.getElementById("play-button").innerHTML = "Stop";
      this.start(); // Set variables to start game
    } //BUG1 
    else { // End game, reset relevant variables
      // TODO: Reset timeStamp(?)
      timeStamp = 0;
      go = true;
      startLoop = false;
      // As of now, toggling button to end the game will lose all progress
      toggle(canvas); // Hide canvas
      document.getElementById("demo").innerHTML = "Game Over";
      document.getElementById("play-button").innerHTML = "Play";
      this.reset(); // Reset important variables
    }
  }

  function _start() {
    // PREP
    // Reset important variables

    // Update canvas
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    _player1.setup();

    //RELOCATION
    _entities.push(_player1);


    // Set up initial invader rows (use from stack if previous game played 
    // already)
    _inv.setup();
    // Initialize structure that displays bullets (clears array)
    //shotKeeper.setup();

    // LOOP
    // Initiate gameLoop, request function gives the browser some air while 
    // looping and time the game loop to be in-sync with the browser repaint
    startLoop = true;
    window.requestAnimationFrame(_gameLoop);
  }

  function _gameLoop(timeStamp) { // TODO: Reset timeStamp(?)
    if(!startLoop) {// Conditional that stops loop 
      return;
    }
    // [ 1 ] UPDATE
    // dt = delta t. the difference in time (seconds) between this and last frame
    dt = (timeStamp - oldTimeStamp)/1000;
    dt = Math.min(0.1, dt);
    oldTimeStamp  = timeStamp;

    // Calculate FPS (for the display)
    fps = Math.round(1/dt);

    _player1.update(dt);
    _player1.shoot(); // Update shotkeeper with any bullets player shot

    //WIP: Gonna edit invaders to move according to time passed
    _inv.update();
    _inv.shoot();

    physics.shotKeeper.update();
    document.getElementById("bull").innerHTML = "bullets: " + _shots.length;

    // [ 2 ] COLLISION DETECTION
    // [Bullet => Check for collision]
    // TODO: Cassie (i.e. player token collision)
    // _player1.intersect(); 
    // [Bullets => iterate invaders]

    // Invader collision check (only first row for now)
    //PLACEMAT
    _invadarr.a.forEach(function(row, rind) { // row index
      row.forEach(function(invader, cind) { // column index
        physics.shotKeeper.collisionCheck(invader);
        // WIP
        // If a backup invader exists, begins attacking after frontmost dies BULL1
        // if(invader.collision && rind > 0) {
        //   _inv.invadarr.f[rind][cind] = _inv.invadarr.a[rind - 1][cind];
        // }
      });
    });

    // [ 3 ] CLEAR
    renderer.clear();

    // [ 4 ] DRAW
    // _player1.draw(); // Relocation: moved to renderer
    renderer.render();
    framesPerSecond(); // Just a display //BUG1 - Displaying bullets for now
    // TODO: Reset timeStamp(?) Not sure if possible

    // Keep requesting further iterations of 'gameLoop' to animate game
    // TODO: Reset timeStamp(?)
    window.requestAnimationFrame(_gameLoop);
  }

  function _clear() { // Clears the whole canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  function _reset() {
    // All settings and game components are at their starting values
    //this.clear(); // Might not need this here

    // clearInterval(this.interval); // nothing should be moving/responding
    // clearAnimationFrame(this.animationFrame);
    dt  = 0;
    oldTimeStamp   = 0;
    timeStamp      = 0; // TODO: Reset timeStamp(can it be done?)

    _shots    = [];
  }

  return { 
    tog:      _tog, // method accessors
    start:    _start,
    gameLoop: _gameLoop,
    clear:    _clear,
    reset:    _reset,

    entities: function() { return _entities; }, // data accessors
    player1:  function() { return _player1;  },
    inv:      function() { return _inv;      },
    invadarr: function() { return _invadarr; },
    shots:    function() { return _shots;    }
  };
})();
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
// â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

// Abstract objects/classes
function rectangle(_x = 0, _y = 0, width = 1, height = 1) {
  // Constructor lines
  this._x      = _x;
  this._y      = _y;
  this.height = height;
  this.width  = width;
  // Rectangle objects exist in the 2D canvas, and canvas coordinates are as
  // follows:
  //       w i d t h
  // (0, 0) -- -- -- >(1,0)   _x
  // h    | â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    (top)
  // e    | â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  // i    | â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    (bottom)
  // g    V(0,1)
  // h
  // t    _y
  //
  // Meaning the y-axis is upside-down compared to y-axis in the standard
  // coordinate plane. Even though the canvas' positive y-axis lies on the 4th
  // quadrant (where the entire visible 2D canvas resides), the rectangle's top
  // will continue to be the top as we know it (i.e. in the real world, a box
  // has a top, and if we flip it over, it still has a side we'd call the top
  // even though its a different side of the box).

  // Methods return _x,_y coordinates of rectangle's corners
  this.left = function() {
    return this._x;
  }

  this.right = function() {
    return this._x + this.width;
  }

  this.top = function() {
    return this._y;
  }

  this.bottom = function() {
    return this._y + this.height;
  }

  // Meethod to check if two rectangles intersect
  this.intersect = function(thatRectangle) {
      if(thatRectangle.left() > this.right()  ||
         this.left() > thatRectangle.right()  ||
         thatRectangle.top() > this.bottom()  ||
         this.top() > thatRectangle.bottom()) {

        return false;
      }
        return true;
  }
}

// Generic game token
function gameToken(position, width = 50, height = 70, direction, speed, collided = false, color = "blue") {
  this.position   = position; // position vector (2d)
  this.width      = width;
  this.height     = height;
  // Object position in the (x, y) plane
  this.direction  = direction; // direction vector (2d)
  this.speed      = speed;     // speed vector (2d)
  // Set collision boolean
  this.collided   = collided;
  this.color      = color;

  this.setup = function() { // Stub

  }

  this.update = function() { // Stub

  }

  // Hitbox that covers entirety of token/sprite's 2D area
  this.hitbox = function() {
    return new rectangle(this.position.x - this.width/2, 
                         this.position.y - this.height/2, 
                         this.width, 
                         this.height);
    // Note: Hitbox's coordinates _x, _y are will be at the upper-left corner
    // of token's 2D area so that we can find the top, bottom, left, and
    // right sides of the game token itself that's drawn in the canvas
    //
    //     w i d t h
    //(_x,_y)-------->(1,0)
    //   |   Â» â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  _x = x - width/2
    // h |     â–ˆ  x,y  â–ˆ  _y = y - height/2
    // e |     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 
    // i V
    // g
    // h
    // t
    //
    // where x,y are coordinates of the game token's center
  }
}

function invaderToken(position, width, height, direction, speed, collided = false, color = "blue", fireRate =  1 /*BUG1 fireRate*/) { //BULL1 
  // Ref: javascript function call():
  // call gameToken with the instance that is 'this' invaderToken object, to
  // pass on the arguments invaderToken has in common with gameToken
  gameToken.call(this, position, width, height, direction, speed, collided,
    color); 
  // Inheritance:
  // prototype method lets us add specified properties and methods to the 
  // object that calls it. 
  //gives it the property to create gameToken objects along with any new properties or methods it wants to add (since gameToken.prototype is used as an argument)
  this.prototype = Object.create(gameToken.prototype);  

  this.fireRate  = fireRate;

  var cooldown   = 0; // Time until next shot is available
  var shotChance = 1; // % chance of firing a shot

  this.shoot = function () {
      cooldown += dt;

      if(cooldown > this.fireRate) {
        cooldown = 0;

        // TODO: Reintroduce 'randomized' shots at a later time
        // laChance is French for luck
        //let laChance = Math.floor(Math.random()*101);
        //if(laChance < shotChance) { //@BULL1
          // this.y + height + 1 to ensure bullet doesn't kill origin point  
          //____ fixing this will probably fix program, but the bullets seem to flow nicely atm            
          physics.shotKeeper.addShot(
            /*position:*/     new vector2d(
            /*x*/               this.position.x,
            /*y*/               this.hitbox().bottom() + this.height + 11),
            /*width:*/        5, 
            /*height:*/       10, 
            /*direction:*/    new vector2d(1, 1),
            /*speed:   */     new vector2d(1, 125),
            /*collided:*/     false,
            /*color:*/        "orange");
        }
      //}
  }
}

function invaders(invaderCount = 1, 
                 {invaderWidth = 10, invaderHeight = 10}, 
                 gapSpace = 40, 
                 velocity, 
                 frameRate = 10,
                 invaderRows = 3) { // Makes invaders movement blocky  

  this.invaderCount = invaderCount;
  // invadarr.c = invaderCount; // Number of invaders per row (read: columns)
  var vw = invaderWidth;
  var vh = invaderHeight;

  var b = gapSpace; // Space [ b ]etween each invader

  this.velocity = velocity;

  var frameUpper = frameRate;
  this.invaderRows = invaderRows;

  var frameNum = 0; // Marks the current frame you're on
  var vLeftmost, vRightmost; //leftmost and rightmost invaders
  // var moveRight = true;
  // let xMagnitude = 1;
  // this.xMagnitude = xMagnitude;

  var wait = false; // 'turns' (frameRate) invaders must wait before moving again

  this.setup = function() {
    if(!invadersMem) {
      gameArea.invadarr().clear(); // Make sure invader array is clear (sanity check mostly)
      // invadarr.a = [];
    }

    frameNum = 0; // Start waiting time from 0

    //
    // SETUP AND SPACING
    // Relative space between each invader
    // x coordinate of next invader's left side, count for previous invader's
    // width and add the gap space
    let next = vw + b;
    // Space between leftmost & rightmost invader boundaries and the canvas 
    // boundary
    //let edgeSpace = (canvas.width - invaderCount *vw - b *(invaderCount - 1))/2;
    let edgeSpace = (canvas.width - invaderCount * (vw + b))/2 + b;
    //let step = edgeSpace/5; // Arbitrary (get to evenly go to edge)
    // Where to begin drawing the invaders centered in the canvas' x axis
    let drawAt = edgeSpace;  
    // GRID
    let y = vh/2; // initial y positioning (at canvas boundary)
    let rowSpace = 100; // space between each row

    // EACH INDIVIDUAL INVADER
    if(!invadersMem) {
      gameArea.invadarr().addRows(invaderRows);
      // Populate with invaderCount number of invaders
      for(let i = 0; i < invaderRows; ++ i) {
        for(let j = 0; j < invaderCount; ++ j) {
          gameArea.invadarr().a[i].push(
                                  new invaderToken(
                                    /*position*/   new vector2d (drawAt, y),
                                    /*width:*/     vw, 
                                    /*height:*/    vh,  
                                    /*direcion:*/  new vector2d(1, 0),
                                    /*speed:   */  new vector2d(10, 10),
                                    /*collided:*/  false,
                                    /*color:*/     "green",
                                    /*fireRate*/   1));
          gameArea.entities().push(gameArea.invadarr().a[i][j]);
          drawAt += next ;
        }
        drawAt = edgeSpace;
        y += rowSpace; // GRID
      }
      invadersMem = true;
    }

    else { // Recycle invader array if it already existed
      //xVelocity < 0 ? xVelocity * -1 : xVelocity; // make sure moving to right
      if(velocity.x < 0) { // make sure invaders initially moving to the right
        velocity.x *= -1;
      }

      gameArea.invadarr().a.forEach(function(row) {
        row.forEach(function(invader) {
          // Reset positioning and other pertinent values
          // invader.position = {drawAt, y};
          invader.position.x = drawAt;
          invader.position.y = y;
          drawAt += next;
          invader.collided = false; // All invaders intact
          invader.cooldown = 0; // Reset shot cooldown time
        });   
        drawAt = edgeSpace;
        y += rowSpace; // Y axis space for next row of invaders
      });
    }
    gameArea.invadarr().setup(); // Set (or reset, depending) frontliners array

    // SPEED AND DIRECTION
    //xVelocity  = 10; // arbitrary (for now)
    //yVelocity  = 1;
    // velocity = {x: 10, y: 1};
    wait = false;
    // Reference for vaders on both ends of array
    vLeftmost  = gameArea.invadarr().a[0][0];
    vRightmost = gameArea.invadarr().a[0][gameArea.invadarr().a[0].length - 1];
    //vRightmost.xVelocity = 10; /*BUG1: magnitude = 30 */ // TODO: Replace vRightmost.magnitude with just an ordinary instance of magnitude (individual invaders might not need a speedboost defined, so it's wasted on them)
  }

  this.update = function() { // Update positioning
    if (frameNum ++ >= frameUpper) { // causes a blink/flicker effect
      frameNum = 0; // Reset frame

      if(wait) { // move 'forward' y axis by 10 pixels (? TODO: use yVelocity)
        gameArea.invadarr().a.forEach(function(row) {
          row.forEach(function(invader) {
            invader.position.y += 15;
          });
        });
        // Change directions after reaching canvas bound
        velocity.x *= -1;
        wait = false;
      }
      else {
        // Check left and right vader boundaries
        let dist  = velocity.x; //* dt; //TODO: same movement w/ seconds
        let distR = vRightmost.hitbox().right() + dist;
        let distL = vLeftmost.hitbox().left() + dist;

        // Movement based on canvas boundary collisions
        // Right boundary of canvas
        if(distR > canvas.width) { 
          // Calculate distance needed to reach rightmost canvas edge
          let toRightBound = canvas.width - vRightmost.hitbox().right();

          // Move all invaders distance needed for rightmost invader to reach
          // canvas edge (and then move opposite direction in the next instance)
          gameArea.invadarr().a.forEach(function(row) {
            row.forEach(function(invader) {
              invader.position.x += toRightBound;
            });
          });

          wait = true; // invaders wait at corner for two 'turns' (frameRate)
        }

        // Left boundary of canvas
        else if(distL <= 0) { // left boundary, change direction  
          // make vaders touch left bound, same as distance of leftmost to bound
          let toLeftBound = 0 - vLeftmost.hitbox().left();

          gameArea.invadarr().a.forEach(function(row) {
            row.forEach(function(invader) { // right boundary
              invader.position.x += toLeftBound;
            });
          });

          wait = true;
        }

        else gameArea.invadarr().a.forEach(function(row) { // default, move
          row.forEach(function(invader) {
            invader.position.x += dist;
          });
        });
      }
    }
  }

  this.shoot = function() {
    if(!wait) {
      gameArea.invadarr().f.forEach(function(frontliner) { // Frontmost invaders will shoot
        if(!frontliner.collided) {
//--------
            frontliner.shoot();
//--------            
        }
      });
    }
  }
}

// Optional: With inheritance, can add new properties at the end of 'fireRate'
// Made into 'class' in case multiplayer gets established later
function playerToken(position, width, height, direction, speed, /* BULL1->speed = 125,0*/ collided = false, color = "red", fireRate = .25) {
  // playerToken inherits from more generic gameToken class
  gameToken.call(this, position, width, height, direction, speed, collided, color);
  this.prototype = Object.create(gameToken.prototype);

  // this.position  = position;
  // this.width     = width;
  // this.height    = height;
  // this.direction = direction;
  // this.speed     = speed;
  // this.collided  = collided;
  // this.color     = color;
  this.fireRate  = fireRate;

  var cooldown = 0;

  this.setup = function() { // RELOCATION: Moving setup to renderer
    // Set up player token's positioning (bottom-center)
    // Subtracting(read: displacing) by player token dimensions to accomodate 
    // for token's size 
    this.position.x = canvas.width/2;
    this.position.y = canvas.height - this.height/2;
  }

  this.update = function(dt) {
    // Variables tell what arrow keys are being pressed
    // canvas = document.getElementById("game-canvas");
    let right = activeKeys[ArrowRight];
    let left = activeKeys[ArrowLeft];
    // Directions left gets 'closer' to zero while right moves 'away'
    let leftWards = -1;
    let rightWards = 1;


    // Player token direction based on arrow keys
    if (left && !right) {
      holding = 'left';
      this.direction.x = leftWards;
    }
    if(!left && right) {
      holding = 'right';
      this.direction.x = rightWards;
    }
    if(left && right) { // Special case: player holds both arrows
      if(holding == 'right') { // Was holding right first
        // movex = leftWards; // Choose left arbitrarily
        this.direction.x = leftWards;
      }
      if(holding == 'left') { // Was holding left first
        // movex = rightWards; // Most recent is right, so go right
        this.direction.x = rightwards;
      }
      if(holding == '') { // Edge case, pressed both at exact time, choose one
        holding = 'right';
        // movex = rightWards;
        this.direction.x = rightwards; 
      }
    }
    if(!right && !left) {
      holding = ''; // Reset, player is not holding either
      this.direction.x = 0;
    }

    let velocity = this.direction.x * this.speed.x;
    // (velocity = distance/time_passed) * time_passed * const =distance * const
    this.position.x += velocity * dt;

    if(this.hitbox().left() <= 0) { // Boundary (move no further)
      this.position.x = this.width/2;
    }
    else if(this.hitbox().right() >= canvas.width) { // Boundary (move back)
      this.position.x = canvas.width - this.width/2; 
    }
    else { // Move forward
    }
  }

  this.shoot = function() {
    let space = activeKeys[Space]; // Press < space > to shoot
    cooldown += dt; // Time until you can shoot again
    if (space && cooldown > fireRate) {
      cooldown = 0;
      let bHeight = 4;
      // (x,y) displacement accomodates for token's dimensions
      // Shot originates from middle of token and travels up
      // Negative velocity because player's bullets go up
      // physics.shotKeeper.addShot(5, 10, "yellow", this.x + width/2, this.y - height/2, 
      // Bullet spawns just above the player token 
      // 
      //  [ ]    Bullet height = Token height/2, spawns, a total distance of
      //         Token height/2 - 1 above player token without touching it
      // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              |
      //   *(x, y) Center   | Token height 
      // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              |
      // Code below ensures bullet spawns 1 unit above top of player's hitbox
      physics.shotKeeper.addShot(/*position*/      new vector2d(
                                            this.position.x,
                                            this.hitbox().top() - bHeight - 1),
                         /*width:*/        5, 
                         /*height:*/       bHeight,
                         /*direction:*/    new vector2d(0, -1),
                         /*speed:*/        new vector2d(0, 500),
                         /*collided:*/     false,
                         /*color*/         "yellow");
    }
  }
}

// ************************************Extra***********************************
function framesPerSecond() { // Displays fps on canvas
//   // Extra: Display FPS on canvas                  
  ctx.fillStyle = "rgba(0, 0, 0, 0)";
  ctx.fillRect(0, 0, 200, 100);
  ctx.font = '15px Arial';
  ctx.fillStyle = 'white';
  // ctx.fillText("Bullets: " +  shots.length);
  ctx.fillText("fps: " + fps, canvas.width - 50, canvas.height - 10);
  // ctx.fillText("playerBH: " + playerBH, canvas.width - 150, canvas.height - 50);
}

</script>
<noscript>Error: Please download JavaScript for your browser.</noscript>

<!-- ---------------------------------------------------------------------- -->
                               <!-- Page body -->

<!-- Canvas CSS (keep here for now for ease of editing) -->
<style>
  /*Include to hide HTML element by default*/
  .hidden {
    display: none;
  }

  #play-button {
    /*Needs absolute positioning to work even inside the canvas*/
    position: absolute;
  }

  html, body {
    /*Give page dimensions so canvas can encompass entirety of page*/
    width:  100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }

  #game-canvas {
    /*Temporary border*/
    border: 2px solid #38e3c4;
    position: absolute;
    z-index: 0;
    /*z-index: 1;*/
    /*TODO: Make good scaling*/
    /*width: 100%;
    height: 100%;*/
    top:  0px;
    left: 0px;
    background: transparent;
  }
</style>