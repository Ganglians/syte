<!-- Game's javascript (place directly for now to reduce compiling time) -->
<!-- < %= javascript_pack_tag 'game' %> -->
<script>
// Resizes game's canvas (A.K.A. 'gameArea') to dynamic page size (i.e. When 
// user changes their browser's size)
window.addEventListener("resize", function(event) {
  canvas = document.getElementById("game-canvas");
  if (canvas.width  < window.innerWidth) {
    canvas.width  = window.innerWidth;
  }

  if (canvas.height < window.innerHeight) {
    canvas.height = window.innerHeight;
  }
});

// 'node' = 'window' in this case
// Deal with player token's controls 
window.addEventListener('keydown', function(event) {
  activeKeys[event.key] = true; // Player presses a key, true in array
});
window.addEventListener('keyup', function(event) {
  activeKeys[event.key] = false; // Player stops pressing key, false in array
});  

// Player token's name
var cassie = new playerToken(40, 40, "red");
let inv = new invaders(totalInvaders = 8, {invaderWidth: 60, invaderHeight: 30}, 
                       gapSpace = 2, frameRate = 25);

// Object list of which current keys are being pressed (i.e. 'keydown') or not
var activeKeys = {};
var holding = '';

// Function that toggles an element's visibility
const toggle = (elem) => {
    elem.classList.toggle('hidden');
}

var gameArea = {
  //cassie = new playerToken(40, 40, red, window.innerWidth/2, window.innerHeight),
  start : function() {
    // Make sure values are at their default when game is starting
    this.reset();
    this.canvas = document.getElementById("game-canvas");
    // Set demo text to indicate game is starting (for now, just to verify)
    document.getElementById("demo").innerHTML = "Game start";

    // Make canvas visible
    toggle(this.canvas);
    // Set up canvas dimensions
    this.canvas.width  = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.ctx = this.canvas.getContext("2d");

    // Set up player token's positioning
    cassie.x = this.canvas.width/2 - cassie.width/2;
    cassie.y = this.canvas.height - cassie.height; // accomodate for object's size

    inv.setup(this.canvas.width);

    // First argument:  Function that loops while game is active. Updates all game tokens
    // Second argument: Essentially how fast game will be moving (framerate)
    this.interval = setInterval(gameFrame, 5);
  },

  clear : function() {
    // [i] TODO using 'canvas' and 'ctx' in multiple functions of 'gameArea' need to DRY this out
    this.canvas = document.getElementById("game-canvas");
    this.ctx = this.canvas.getContext("2d");
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  },

  reset: function() {
    // All settings and game components are at their starting values
    //this.clear(); // Might not need this here

    clearInterval(this.interval); // nothing should be moving/responding
    // invaders
    invaders = []; // erase invaders 
  }
}

// Abstract object 
function gamePart(width, height, color = "blue", x = 0, y = 0) {
  this.width = width;
  this.height = height;
  this.color = color;
  // Object position in the (x, y) plane
  this.x = x;
  this.y = y;

  this.draw = function() { // Redraw according to new positioning
    ctx = gameArea.ctx;   
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7; // Opacity
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }

  // TODO: INHERITANCE and replace this function with a different one of the same name
  this.newPos = function() {
  } 

  // Determines whether or not one object has intersected another object's boundaries 
  this.collision = function() {
    // TODO
  }
}

// Invader's game token
function invaderToken(width, height, color, x, y, velocity, speedBoost = 1) {
  // invaderToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: invaderToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });  
}

function invaders(invaderCount = 1, {invaderWidth = 10, invaderHeight = 10},
                  gapSpace = 20, frameRate = 250) {
  var invadArr = [];

  // Set invader properties to argument counterpart values
  this.invaderCount = invaderCount;
  var vw = invaderWidth;
  var vh = invaderHeight;
  var b = gapSpace; // Space [ b ]etween each invader
  var frameUpper = frameRate;

  var frameNum = 0; // Marks the current frame you're on
  var vLeftmost, vRightmost;
  // var moveRight = true;
  var velocity = 1;

  this.setup = function(can = 100) {
    invadArr = []; // Make sure invader array is clear
    canvasW = can; // Get canvas width from setup method call
    frameNum = 0; // Reset frame number
    // moveRight = true;

    // Invader setup and spacing

    // Relative space between each invader
    // X Coordinate of next invader acconuting for previous width
    let next = vw + b;
    // Space between left most & rightmost invaders and the canvas boundary
    let edgeSpace = (canvasW - invaderCount*vw - b*(invaderCount - 1))/2;
    let step = edgeSpace/5; // Arbitrary (get to evenly go to edge)
    let drawAt = edgeSpace; // Where to start invaders so group of them is centered

    for(let i = 0; i < invaderCount; i ++) {
      invadArr.push(new invaderToken(vw, vh, "green", drawAt, 0, 1, step));
      drawAt += next;
    }
    // Reference for invaders at both ends
    vLeftmost  = invadArr[0];
    vRightmost = invadArr[invadArr.length - 1];

    velocity = 1; // Start off moving to the right
    vRightmost.speedBoost = 30;
  }

  this.move = function() {
    if (frameNum ++ >= frameUpper) {
      frameNum = 0; // Reset frame
      distR = vRightmost.x + velocity*vRightmost.speedBoost;
      distL = vLeftmost.x + velocity*vRightmost.speedBoost;

      // Movement based on canvas collision
      if(distR + vRightmost.width >= canvasW || distL <= 0) { 
        velocity *= -1;

        invadArr.forEach(function(invader) { 
          invader.y += 5;
        });       
      }

      invadArr.forEach(function(invader) { 
        invader.x += velocity * vRightmost.speedBoost;
      });
    }
    // Redraw
    invadArr.forEach(function(invader) {
      invader.draw();// Won't be needed if dirty rectangles implemented
    });
  }
}

// Can add new properties at the end of 'speedBoost'
function playerToken(width, height, color, x, y, velocity = 0, speedBoost = 1) {
  // playerToken inherits from more generic gamePart class
  gamePart.call(this, width, height, color, x, y, velocity, speedBoost);
  this.prototype = Object.create(gamePart.prototype);
  Object.defineProperty(this, 'constructor', { 
      value: playerToken, 
      enumerable: false, // so that it does not appear in 'for in' loop
      writable: true 
  });

  this.velocity = velocity;
  this.speedBoost = speedBoost;

  // var canvas = document.getElementById("game-canvas");
  this.newPos = function() {
    // Variables tell what arrow keys are being pressed
    canvas = document.getElementById("game-canvas");
    right = activeKeys['ArrowRight'];
    left = activeKeys['ArrowLeft'];
    dist = this.x + this.velocity * this.speedBoost;
    if (left && !right) {
      holding = 'left';
      this.velocity = -1;
    }
    if(!left && right) {
      holding = 'right';
      this.velocity = 1;
    }
    if(left && right) { // Special case: player holds both arrows
      if(holding == 'right') { // Was holding right first
        this.velocity = -1; // Most recent is left
      }
      if(holding == 'left') { // Was holding left first
        this.velocity = 1; // Most recent is right
      }
      if(holding == '') { // Edge case, pressed both at exact time, choose one
        holding = 'right';
        this.velocity = -1; 
      }
    }
    if(!right && !left) {
      holding = ''; // Reset, player is not holding either
      this.velocity = 0;
    }

    // Stay in canvas' boundaries 
    if(dist == 0) {
      // Keep in the same place
    }
    else if(dist < 0) {
      this.x = 0;
    }
    else if(dist + this.width == canvas.width) {
      // Keep in the same place
    }
    else if(dist + this.width > canvas.width) {
      this.x = canvas.width - this.width; 
    }
    else {
      this.x = dist;
    }
  }
}

function gameFrame() {
  gameArea.clear(); // TODO: Optimize don't need to clear canvas each time
  cassie.newPos();
  cassie.draw();
  inv.move(); 
}

function gameOn() {
  gameArea.start();
}
</script>
<noscript>Error: Please download JavaScript for your browser.</noscript>


<!-- Page body -->

<!-- Canvas CSS (keep here for now for ease of editing) -->
<style>
  /*Include to hide HTML element by default*/
  .hidden {
    display: none;
  }

  #play-button {
    /*Needs absolute positioning to work even inside the canvas*/
    position: absolute;
  }

  html, body {
    /*Give page dimensions so canvas can encompass entirety of page*/
    width:  100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
  }

  #game-canvas {
    /*Temporary border*/
    border: 2px solid #38e3c4;
    position: absolute;
  }
</style>

<!-- Add game's canvas, initially hidden because it's only needed when user 
  decides to play the game and clicks play button -->
<canvas id="game-canvas" class="hidden"> 
Your browser does not support the HTML canvas tag.
</canvas>
<!-- Button click event: press to start the game script-->
<button id="play-button" type="button" onclick="gameArea.start()">Play</button>